<!DOCTYPE html>
<html lang="en">

<!--
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Left Identity Element Property</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }

    .set-container {
      margin-bottom: 20px;
    }

    .set-name {
      font-weight: bold;
      font-size: 1.2em;
    }

    .set-elements {
      margin-top: 10px;
      font-size: 1.5em;
    }

    select {
      font-size: 1em;
      width: auto;
      padding: 5px;
    }

    option {
      font-size: 1em;
      white-space: nowrap;
    }

    option span {
      font-weight: bold;
      margin-right: 10px;
    }

    .table {
      margin: 20px auto;
      border-collapse: collapse;
      width: 50%;
    }

    .element-condition-wrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      margin-top: 20px;
      gap: 10px;
    }

    .operation-symbol {
      color: #592adb;
      font-weight: bold;
      text-align: center;
    }

    #element-check-table,
    #condition-check-table {
      margin: 0;
      border-collapse: collapse;
      width: auto;
    }

    #element-check-table th,
    #condition-check-table th {
      height: 50px;
      padding: 10px;
      text-align: center;
    }

    #element-check-table .result-column {
      width: 300px;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: center;
    }

    th {
      background-color: #f4f4f4;
    }

    .highlight {
      background-color: yellow;
    }

    .navigation-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    .step-label {
      font-size: 18px;
      font-weight: bold;
    }

    button {
      text-decoration: none;
      display: inline-block;
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      font-size: 24px;
    }

    button:hover {
      background-color: #ddd;
      color: black;
    }

    .previous {
      background-color: #f1f1f1;
      color: black;
    }

    .next {
      background-color: #04AA6D;
      color: white;
    }

    .round {
      border-radius: 50%;
    }

    .disabled {
      background-color: #f1f1f1 !important;
      color: #ccc !important;
      pointer-events: none;
    }

    .enabled {
      background-color: #04AA6D;
      color: white;
    }

    .valid-cell {
      background-color: #DFF6DD;
      border: 2px solid #4CAF50;
      color: #2E7D32;
    }

    .invalid-cell {
      background-color: #FDDCDC;
      border: 2px solid #E53935;
      color: #C62828;
    }

    .math-section {
      font-family: 'Georgia', 'Times New Roman', serif;
      margin: 20px auto;
      max-width: 800px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #fdfdfd;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .math-header {
      background-color: #007BFF;
      color: white;
      padding: 10px 15px;
      cursor: pointer;
      text-align: left;
      font-size: 18px;
      border-radius: 8px 8px 0 0;
    }

    .math-header:hover {
      background-color: #0056b3;
    }

    .math-content {
      padding: 20px;
      line-height: 1.6;
      display: block;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }

    .math-content.collapsed {
      max-height: 0;
      padding: 0 20px;
    }

    .math-content h1 {
      font-size: 1.8em;
      margin-bottom: 20px;
      text-align: center;
    }

    .math-content p {
      margin-bottom: 20px;
    }

    .math-content code {
      font-family: 'Courier New', monospace;
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 4px;
    }

    .math-content em {
      font-style: italic;
    }
  </style>
</head>

<body>
  <h1>Left Identity Element</h1>
  <h3>Demo
    <a href="Left Identity Element demo help.html" target="_blank">
      <!-- https://en.m.wikipedia.org/wiki/File:Icon-round-Question_mark.svg -->
      <img src="question_mark_help.svg" alt="Help" title="Learn more about inverse elements"
        style="width: 16px; height: 16px; margin-left: 5px; cursor: pointer;">
    </a>
  </h3>

  <div class="math-section">
    <div class="math-header" onclick="toggleSection()">
      Left Identity Element (Click to Expand/Collapse)
    </div>
    <div class="math-content" id="mathContent">
      <p>
        A <strong>left identity element</strong> in algebra is a special element in a set that leaves other elements
        unchanged when used in an operation from the left. More formally, if <em>e</em> is the left identity element for
        a binary operation
        <em>*</em> defined on a set <em>S</em>, then for every element <em>x</em> in <em>S</em>, the equation
        <code>e * x = x</code> holds true.
      </p>
      <p>
        The left identity property focuses on the direction of the operation, as it only guarantees that the identity
        element behaves as expected when it appears on the left side of the operation. This is in contrast to a
        two-sided identity, which satisfies
        <code>e * x = x</code> and <code>x * e = x</code> for all <em>x</em> in <em>S</em>.
      </p>
      <p>
        In some algebraic structures, like semigroups or magmas, the existence of a left identity does not necessarily
        imply the existence of a right identity or that the left identity is unique. However, in structures with more
        stringent properties, such as groups or monoids, the left identity often coincides with the right identity,
        resulting in a unique two-sided identity element.
      </p>
      <p>
        Understanding the left identity element is fundamental in exploring the structure of algebraic systems, as it
        plays a role in determining how elements interact and whether certain properties like invertibility can be
        established.
      </p>
    </div>
  </div>

  <div class="set-container">
    <label for="set-select">Choose a set:</label>
    <select id="set-select">
      <option value="Letters" selected>Letters: a b c d e f</option>
    </select>
  </div>

  <label for="element-count">Number of elements:</label>
  <select id="element-count">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4" selected>4</option>
    <option value="5">5</option>
    <option value="6">6</option>
  </select>
  <label for="positive-results">Positive results</label>
    <select id="positive-results">
    <option value="1">1</option>
  </select>
  <span id="positive-results-label">(1 - required)</span>
  <table id="cayley-table" class="table">
    <thead>
      <tr>
        <th></th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>
  <div class="element-condition-wrapper">
    <table id="element-check-table" class="table">
      <thead>
        <tr>
          <th>Element Check</th>
          <th class="result-column">Result</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
    <table id="condition-check-table" class="table">
      <thead>
        <tr>
          <th>Condition<br>e <span class="operation-symbol">*</span> x = x</th>
          <th class="result-column">Result</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>
  <div style="height: 10px;"></div>
  <div class="navigation-controls">
    <button class="previous round" id="backward"><b>&#8249;</b></button>
    <div class="step-label" id="step-label">Step: 1</div>
    <button class="next round" id="forward"><b>&#8250;</b></button>
  </div>

  <script>
    const mathContent = document.getElementById('mathContent');
    const setSelect = document.getElementById('set-select');
    const elementCountSelect = document.getElementById('element-count');
    const positiveResultsSelect = document.getElementById('positive-results');
    const positiveResultsLabel = document.getElementById('positive-results-label');
    const cayleyTableHtml = document.getElementById('cayley-table');
    const elementCheckTableHtml = document.getElementById('element-check-table');
    const conditionCheckTableHtml = document.getElementById('condition-check-table');
    const stepLabel = document.getElementById('step-label');
    const forwardButton = document.getElementById('forward');
    const backwardButton = document.getElementById('backward');

    const sets = {
      Letters: ['a', 'b', 'c', 'd', 'e', 'f'],
      Arrows: ['â†', 'â†‘', 'â†’', 'â†“', 'â†¶', 'â†·'],
      Emoji: ['ðŸ˜ƒ', 'ðŸ¤”', 'ðŸ¥³', 'ðŸ˜Ž', 'ðŸ˜', 'ðŸ˜¨'],
      Geometric: ['â–²', 'â–³', 'â—†', 'â—‡', 'â—', 'â—‹'],
      Weather: ['â˜€', 'â›…', 'â„', 'â˜”', 'ðŸŒž', 'âš¡'],
      Chess: ['â™”', 'â™•', 'â™–', 'â™—', 'â™˜', 'â™™'],
      Stars: ['â˜…', 'â˜†', 'âœ¦', 'âœ´', 'âœ¶', 'âœª'],
      Hearts: ['â¤', 'ðŸ’›', 'ðŸ’™', 'ðŸ’œ', 'ðŸ§¡', 'â¤ï¸'],
      Animals: ['ðŸ¶', 'ðŸ¯', 'ðŸ­', 'ðŸ°', 'ðŸ¦Š', 'ðŸ¼'],
      Plants: ['ðŸŒ±', 'ðŸŒ¿', 'ðŸŒ³', 'ðŸ€', 'ðŸŒ¼', 'ðŸŒº'],
      Food: ['ðŸŽ', 'ðŸŠ', 'ðŸ‹', 'ðŸ‰', 'ðŸ‡', 'ðŸ’'],
      Zodiac: ['â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™'],
      Circles: ['ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£'],
      Tools: ['ðŸ”§', 'ðŸ”¨', 'ðŸª›', 'ðŸª“', 'ðŸ”—', 'ðŸªš'],
      Sports: ['âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ“', 'ðŸ¸'],
      Dice: ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'],
      Transport: ['ðŸš—', 'ðŸšŒ', 'ðŸšŽ', 'ðŸš‘', 'ðŸš’', 'ðŸšš'],
      FancyLetters: ['ð’ž', 'ð’Ÿ', 'â„°', 'ð’¢', 'â„‹', 'â„']
    };

    const colorMap = {
      'a': '#e6194B', // Red
      'b': '#3cb44b', // Green
      'c': '#4363d8', // Blue
      'd': '#f58231', // Orange
      'e': '#911eb4', // Purple
      'f': '#f032e6', // Magenta
      'g': '#bcf60c', // Lime
      'h': '#fabebe', // Pink
      'i': '#ffe119', // Yellow
      'j': '#46f0f0', // Cyan        
    };

    let size = 4;
    let totalCells = size * size;
    let setName = 'Letters';
    let set = sets[setName];
    let elements = set.slice(0, size);
    let isIdentityArray = Array(size).fill(false);
    let step = 1;
    let cayleyTableForwardSteps = [];
    let cayleyTableBackwardSteps = [];
    let elementCheckForwardSteps = [];
    let elementCheckBackwardSteps = [];
    let conditionCheckForwardSteps = [];
    let conditionCheckBackwardSteps = [];
    let cayleyTableData = [];
    let leftIdentityResults = defaultLeftIdentityResultsArray();

    setSelect.addEventListener('change', (event) => {
      updateSet();
    });

    function updateSet() {
      setName = setSelect.value;
      set = sets[setName];
      generateTable();
    }

    elementCountSelect.addEventListener('change', (event) => {
      updateSize();
    });

    function updateSize() {
      size = parseInt(elementCountSelect.value, 10);
      leftIdentityRowResults = Array(size).fill(false);
      totalCells = size * size;

      generateElementsData();
      updatePositiveResultsSelector();
      generateIdentityRowIndicatorArray();
      generateTable();

      if (size === 1) {
        const resultCell = elementCheckTableHtml.rows[1].cells[1];
        let element = elements[0];
        resultCell.innerHTML = `<span style="color: ${colorMap[element] || 'black'}">${element}</span> is a left identity element`;
        resultCell.classList.add('valid-cell');
      }
    }

    positiveResultsSelect.addEventListener('change', (event) => {
      updatePositiveResults();
    });

    function updatePositiveResults() {
      generateIdentityRowIndicatorArray();
      generateTable();
    };

    function generateElementsData() {
      elements = set.slice(0, size);
    }

    function updatePositiveResultsSelector() {
      positiveResultsSelect.innerHTML = '';
      if (size === 1) {
        const option = document.createElement('option');
        option.value = 1;
        option.textContent = 1;
        positiveResultsSelect.appendChild(option);
        positiveResultsLabel.textContent = '(there can only be 1)';
      } else {
        for (let i = 0; i <= size; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = i;
          positiveResultsSelect.appendChild(option);
        }
        positiveResultsSelect.value = '1';
        positiveResultsLabel.textContent = `(0 - ${size})`;
      }
    }

    function generateIdentityRowIndicatorArray() {
      const positiveCount = parseInt(positiveResultsSelect.value, 10);
      isIdentityArray = Array(size).fill(false);
      for (let i = 0; i < positiveCount; i++) {
        let randomIndex;
        do {
          randomIndex = Math.floor(Math.random() * size);
        } while (isIdentityArray[randomIndex]);
        isIdentityArray[randomIndex] = true;
      }
      if (size > 1) {
        for (let i = isIdentityArray.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [isIdentityArray[i], isIdentityArray[j]] = [isIdentityArray[j], isIdentityArray[i]];
        }
      }
    }

    function arraysAreEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) return false;
      return arr1.every((value, index) => value === arr2[index]);
    }

    function generateTableData() {
      generateElementsData();
      generateCayleyTableData();
      generateLeftIdentityResults();
      generateLeftIdentityRowResults();
    }

    function generateCayleyTableData() {
      cayleyTableData = Array.from({ length: size }, () => Array(size).fill(null));
      const leftIdentityValues = elements.slice(0, size);
      elements.forEach((element, rowIndex) => {
        const isIdentityRow = checkIsIdentityRow(rowIndex);
        if (isIdentityRow) {
          cayleyTableData[rowIndex] = [...leftIdentityValues];
        } else {
          let newRow;
          do {
            newRow = Array.from({ length: size }, () => elements[Math.floor(Math.random() * size)]);
          } while (arraysAreEqual(newRow, leftIdentityValues));
          cayleyTableData[rowIndex] = newRow;
        }
      });
    }

    function defaultLeftIdentityResultsArray() {
      const leftIdentityResults = [];
      for (let i = 0; i < size; i++) {
        const row = [];
        for (let j = 0; j < size; j++) {
          row.push(false);
        }
        leftIdentityResults.push(row);
      }
      return leftIdentityResults;
    }

    function generateLeftIdentityResults() {
      leftIdentityResults = defaultLeftIdentityResultsArray();
      for (let rowIndex = 0; rowIndex < size; rowIndex++) {
        for (let colIndex = 0; colIndex < size; colIndex++) {
          leftIdentityResults[rowIndex][colIndex] = checkLeftIdentityCondition(rowIndex, colIndex);
        }
      }
    }

    function generateLeftIdentityRowResults() {
      leftIdentityRowResults = Array(size).fill(false);
      for (let rowIndex = 0; rowIndex < size; rowIndex++) {
        leftIdentityRowResults[rowIndex] = leftIdentityResults[rowIndex].every(result => result);
      }
    }

    function checkIsIdentityRow(rowIndex) {
      return size === 1 || isIdentityArray[rowIndex];
    }

    function checkLeftIdentityCondition(rowIndex, colIndex) {
      const value = cayleyTableData[rowIndex][colIndex];
      const expectedValue = elements[colIndex];
      return value === expectedValue;
    }

    function generateTable() {
      clearTables();
      generateTableData();
      renderTableHeaders();
      renderTableRows();
      renderElementCheckTable();
      renderConditionCheckTable();
      precomputeSteps();
    }

    function clearTables() {
      cayleyTableHtml.querySelector('thead tr').innerHTML = '<th></th>';
      cayleyTableHtml.querySelector('tbody').innerHTML = '';
      elementCheckTableHtml.querySelector('tbody').innerHTML = '';
      conditionCheckTableHtml.querySelector('tbody').innerHTML = '';
    }

    function renderTableHeaders() {
      const thead = cayleyTableHtml.querySelector('thead tr');
      thead.innerHTML = '<th class="operation-symbol">*</th>';
      elements.forEach(element => {
        const th = document.createElement('th');
        th.textContent = element;
        th.style.color = colorMap[element] || 'black';
        thead.appendChild(th);
      });
    }

    function renderTableRows() {
      const tbody = cayleyTableHtml.querySelector('tbody');
      elements.forEach((element, rowIndex) => {
        const row = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = element;
        th.style.color = colorMap[element] || 'black';
        row.appendChild(th);

        for (let colIndex = 0; colIndex < size; colIndex++) {
          const td = document.createElement('td');
          const cellElement = cayleyTableData[rowIndex][colIndex];
          td.innerHTML = `<span style="color: ${colorMap[cellElement] || 'black'}">${cellElement}</span>`;
          row.appendChild(td);
        }
        tbody.appendChild(row);
      });
    }

    function renderElementCheckTable() {
      const checkTbody = elementCheckTableHtml.querySelector('tbody');
      elements.forEach(element => {
        const row = document.createElement('tr');
        const elementCell = document.createElement('td');
        elementCell.innerHTML = `Identity element e = <span style="color: ${colorMap[element] || 'black'}">${element}</span>`;
        const resultCell = document.createElement('td');
        resultCell.classList.add('result-column');
        row.appendChild(elementCell);
        row.appendChild(resultCell);
        checkTbody.appendChild(row);
      });
    }

    function renderConditionCheckTable() {
      const conditionCheckTbody = conditionCheckTableHtml.querySelector('tbody');
      elements.forEach(element => {
        const row = document.createElement('tr');
        const conditionCell = document.createElement('td');
        conditionCell.innerHTML = `e <span class="operation-symbol">*</span> <span style="color: ${colorMap[element] || 'black'}">${element}</span> = <span style="color: ${colorMap[element] || 'black'}">${element}</span>`;
        const resultCell = document.createElement('td');
        resultCell.classList.add('result-column');
        row.appendChild(conditionCell);
        row.appendChild(resultCell);
        conditionCheckTbody.appendChild(row);
      });
    }

    function precomputeSteps() {
      cayleyTableForwardSteps = [];
      cayleyTableBackwardSteps = [];
      elementCheckForwardSteps = [];
      elementCheckBackwardSteps = [];
      conditionCheckForwardSteps = [];
      conditionCheckBackwardSteps = [];

      for (let i = 1; i <= totalCells; i++) {
        const index = i - 1;
        const row = Math.floor(index / size) + 1;
        const col = (index % size) + 1;

        cayleyTableForwardSteps.push(() => {
          cayleyTableHtml.rows[row].cells[col].classList.add(leftIdentityResults[row - 1][col - 1] ? 'valid-cell' : 'invalid-cell');
          cayleyTableHtml.rows[row].cells[0].classList.add('highlight');
          cayleyTableHtml.rows[0].cells[col].classList.add('highlight');
        });
        cayleyTableBackwardSteps.push(() => {
          cayleyTableHtml.rows[row].cells[0].classList.remove('highlight');
          cayleyTableHtml.rows[0].cells[col].classList.remove('highlight');
        });

        elementCheckForwardSteps.push(() => {
          elementCheckTableHtml.rows[row].cells[0].classList.add('highlight');

        });
        elementCheckBackwardSteps.push(() => {
          elementCheckTableHtml.rows[row].cells[0].classList.remove('highlight');
        });

        conditionCheckForwardSteps.push(() => {
          conditionCheckTableHtml.rows[col].cells[0].classList.add('highlight');
          const resultCell = conditionCheckTableHtml.rows[col].cells[1];
          resultCell.textContent = leftIdentityResults[row - 1][col - 1] ? 'True' : 'False';
          resultCell.classList.add(leftIdentityResults[row - 1][col - 1] ? 'valid-cell' : 'invalid-cell');
        });
        conditionCheckBackwardSteps.push(() => {
          conditionCheckTableHtml.rows[col].cells[0].classList.remove('highlight');
        });
      }

      step = 1;
      updateStepLabel();
      updateButtonStates();
      cayleyTableForwardSteps[step - 1]();
      elementCheckForwardSteps[step - 1]();
      conditionCheckForwardSteps[step - 1]();
    }

    function updateStepLabel() {
      stepLabel.textContent = `Step: ${step}`;
    }

    function updateButtonStates() {
      if (step <= 1) {
        backwardButton.classList.add('disabled');
        backwardButton.classList.remove('enabled');
      } else {
        backwardButton.classList.remove('disabled');
        backwardButton.classList.add('enabled');
      }
      if (step >= totalCells) {
        forwardButton.classList.add('disabled');
        forwardButton.classList.remove('enabled');
      } else {
        forwardButton.classList.remove('disabled');
        forwardButton.classList.add('enabled');
      }
    }

    forwardButton.addEventListener('click', (event) => {
      event.preventDefault();
      if (step < totalCells) {
        cayleyTableBackwardSteps[step - 1]();
        elementCheckBackwardSteps[step - 1]();
        conditionCheckBackwardSteps[step - 1]();

        let index = step - 1;
        let row = Math.floor(index / size) + 1;
        let col = (index % size) + 1;

        // Clear Cayley Table entries of previous rown on new row. The entries will be added one cell at a time.
        if (step % size == 0) {
          for (let col = 0; col < size; col++) {
            const resultCell = cayleyTableHtml.rows[row].cells[col + 1];
            resultCell.classList.remove('valid-cell', 'invalid-cell');
          }
        }

        // Clear Condition Table entries on new row. The entries will be added one cell at a time.
        if (step % size == 0) {
          for (let row = 0; row < size; row++) {
            const resultCell = conditionCheckTableHtml.rows[row + 1].cells[1];
            resultCell.textContent = '';
            resultCell.classList.remove('valid-cell', 'invalid-cell');
          }
        }

        step++;

        index = step - 1;
        row = Math.floor(index / size) + 1;
        col = (index % size) + 1;

        // When new row, for Element Check Table show next value.
        if (col == size) {
          const resultCell = elementCheckTableHtml.rows[row].cells[1];
          let element = elements[row - 1];
          resultCell.innerHTML = leftIdentityRowResults[row - 1] ? `<span style="color: ${colorMap[element] || 'black'}">${element}</span> is a left identity element` : `<span style="color: ${colorMap[element] || 'black'}">${element}</span>  is not a left identity element`;
          resultCell.classList.add(leftIdentityRowResults[row - 1] ? 'valid-cell' : 'invalid-cell');
        }

        cayleyTableForwardSteps[step - 1]();
        elementCheckForwardSteps[step - 1]();
        conditionCheckForwardSteps[step - 1]();
        updateStepLabel();
        updateButtonStates();
      }
    });

    backwardButton.addEventListener('click', (event) => {
      event.preventDefault();
      if (step > 1) {
        cayleyTableBackwardSteps[step - 1]();
        elementCheckBackwardSteps[step - 1]();
        conditionCheckBackwardSteps[step - 1]();

        let index = step - 1;
        let row = Math.floor(index / size) + 1;
        let col = (index % size) + 1;

        // Remove previous result from Cayley Table
        const cayleyTableResultCell = cayleyTableHtml.rows[row].cells[col];
        cayleyTableResultCell.classList.remove('valid-cell', 'invalid-cell');

        // Remove previous result from Condition Table
        // Remember the table is for a list of values in a row so use col as index for rows array.
        const conditionTableResultCell = conditionCheckTableHtml.rows[col].cells[1];
        conditionTableResultCell.textContent = '';
        conditionTableResultCell.classList.remove('valid-cell', 'invalid-cell');

        step--;

        // Since step changed need to calculate row and col again.
        index = step - 1;
        row = Math.floor(index / size) + 1;
        col = (index % size) + 1;

        // Remove previous result from Element Check Table
        if (col == (size - 1)) {
          const resultCell = elementCheckTableHtml.rows[row].cells[1];
          resultCell.textContent = '';
          resultCell.classList.remove('valid-cell', 'invalid-cell');
        }

        // When row change, for Cayley Table show all values.
        if (col == size) {
          for (let col = 0; col < size; col++) {
            const resultCell = cayleyTableHtml.rows[row].cells[col + 1];
            resultCell.classList.add(leftIdentityResults[row - 1][col] ? 'valid-cell' : 'invalid-cell');
          }
        }

        // When row change, for Condition Table show all values.
        if (col == size) {
          for (let col = 0; col < size; col++) {
            const resultCell = conditionCheckTableHtml.rows[col + 1].cells[1];
            resultCell.textContent = leftIdentityResults[row - 1][col] ? 'True' : 'False';
            resultCell.classList.add(leftIdentityResults[row - 1][col] ? 'valid-cell' : 'invalid-cell');
          }
        }

        cayleyTableForwardSteps[step - 1]();
        elementCheckForwardSteps[step - 1]();
        conditionCheckForwardSteps[step - 1]();
        updateStepLabel();
        updateButtonStates();
      }
    });

    for (const setName in sets) {
      const option = document.createElement('option');
      option.value = setName;
      if (setName === 'Letters') {
        option.textContent = `${setName}: selected ${sets[setName].join(' ')}`;
      } else {
        option.textContent = `${setName}: ${sets[setName].join(' ')}`;
      }
      setSelect.appendChild(option);
    }

    function toggleSection() {
      mathContent.classList.toggle('collapsed');
    }

    updateSize();
  </script>

  <footer>
    <p>
      Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License 2.0</a>.
    </p>
  </footer>
</body>

</html>
