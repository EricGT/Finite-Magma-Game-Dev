<!DOCTYPE html>
<html lang="en">

<!--

Copyright 2024 Eric G. Taucher

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Identity Element Property</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }

        .set-container {
            margin-bottom: 20px;
        }

        .set-name {
            font-weight: bold;
            font-size: 1.2em;
        }

        .set-elements {
            margin-top: 10px;
            font-size: 1.5em;
        }

        select {
            font-size: 1em;
            width: auto;
            padding: 5px;
        }

        option {
            font-size: 1em;
            white-space: nowrap;
        }

        option span {
            font-weight: bold;
            margin-right: 10px;
        }

        .table {
            margin: 20px auto;
            border-collapse: collapse;
            width: 80%;
        }

        .element-condition-wrapper {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin-top: 20px;
            gap: 10px;
        }

        .operation-symbol {
            color: #592adb;
            font-weight: bold;
            text-align: center;
        }

        #element-check-table,
        #condition-check-table {
            margin: 0;
            border-collapse: collapse;
            width: auto;
        }

        #element-check-table th,
        #condition-check-table th {
            height: 50px;
            padding: 10px;
            text-align: center;
        }

        #element-check-table .result-column,
        #condition-check-table .result-column {
            width: 300px;
        }

        th,
        td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: center;
        }

        th {
            background-color: #f4f4f4;
        }

        .highlight {
            background-color: yellow;
        }

        .navigation-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .step-label {
            font-size: 18px;
            font-weight: bold;
        }

        button {
            text-decoration: none;
            display: inline-block;
            padding: 8px 16px;
            border: none;
            cursor: pointer;
            font-size: 24px;
        }

        button:hover {
            background-color: #ddd;
            color: black;
        }

        .previous {
            background-color: #f1f1f1;
            color: black;
        }

        .next {
            background-color: #04AA6D;
            color: white;
        }

        .round {
            border-radius: 50%;
        }

        .disabled {
            background-color: #f1f1f1 !important;
            color: #ccc !important;
            pointer-events: none;
        }

        .enabled {
            background-color: #04AA6D;
            color: white;
        }

        /* Default: No color change */
        .identity-cell-default {
            color: inherit;
            /* No specific color applied */
        }

        .valid-cell {
            background-color: #DFF6DD;
            border: 2px solid #4CAF50;
            color: #2E7D32;
        }

        /* Green color: left-valid only, right-valid only, or both */
        .left-valid:not(.right-valid),
        .right-valid:not(.left-valid),
        .left-valid.right-valid {
            background-color: #DFF6DD;
            border: 2px solid #4CAF50;
            color: #2E7D32;
        }

        .invalid-cell {
            background-color: #FDDCDC;
            border: 2px solid #E53935;
            color: #C62828;
        }

        /* Red color: left-invalid only, right-invalid only, or both */
        .left-invalid:not(.right-invalid),
        .right-invalid:not(.left-invalid),
        .left-invalid.right-invalid {
            background-color: #FDDCDC;
            border: 2px solid #E53935;
            color: #C62828;
        }

        .math-section {
            font-family: 'Georgia', 'Times New Roman', serif;
            margin: 20px auto;
            max-width: 800px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fdfdfd;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .math-header {
            background-color: #007BFF;
            color: white;
            padding: 10px 15px;
            cursor: pointer;
            text-align: left;
            font-size: 18px;
            border-radius: 8px 8px 0 0;
        }

        .math-header:hover {
            background-color: #0056b3;
        }

        .math-content {
            padding: 20px;
            line-height: 1.6;
            display: block;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .math-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }

        .math-content h1 {
            font-size: 1.8em;
            margin-bottom: 20px;
            text-align: center;
        }

        .math-content p {
            margin-bottom: 20px;
        }

        .math-content code {
            font-family: 'Courier New', monospace;
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .math-content em {
            font-style: italic;
        }
    </style>
</head>

<body>
    <h1>Identity Element</h1>
    <h3>Demo
        <a href="Identity Element demo help.html" target="_blank">
            <!-- https://en.m.wikipedia.org/wiki/File:Icon-round-Question_mark.svg -->
            <img src="question_mark_help.svg" alt="Help" title="Learn more about identity elements"
                style="width: 16px; height: 16px; margin-left: 5px; cursor: pointer;">
        </a>
    </h3>

    <div class="math-section">
        <div class="math-header" onclick="toggleSection()">
            Identity Element (Click to Expand/Collapse)
        </div>
        <div class="math-content" id="mathContent">
            <p>
                An <strong>identity element</strong> in algebra is an element in a set that leaves other elements
                unchanged when used
                in an operation from either side. More formally, if <em>e</em> is the identity element for a binary
                operation
                <em>*</em> defined on a set <em>S</em>, then for every element <em>x</em> in <em>S</em>, the equations
                <code>e * x = x</code> and <code>x * e = x</code> hold true.
            </p>
            <p>
                The identity property ensures that the element behaves as expected when it appears on both the left and
                right sides
                of the operation. This is in contrast to left or right identity elements, which only satisfy one of the
                two equations.
            </p>
            <p>
                In algebraic structures like groups and monoids, the identity element is unique. It plays a crucial role
                in defining
                invertible elements and understanding the structure of the algebraic system.
            </p>
            <p>
                Recognizing the identity element is fundamental in exploring algebraic properties and operations within
                a set.
            </p>
        </div>
    </div>

    <div class="set-container">
        <label for="set-select">Choose a set:</label>
        <select id="set-select">
            <option value="Letters" selected>Letters: a b c d e f</option>
        </select>
    </div>

    <label for="element-count">Number of elements:</label>
    <select id="element-count">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4" selected>4</option>
        <option value="5">5</option>
        <option value="6">6</option>
    </select>
    <label for="positive-results">Positive results</label>
    <select id="positive-results">
        <option value="0">0</option>
        <option value="1" selected>1</option>
    </select>
    <span id="positive-results-label">(0 - 1)</span>
    <table id="cayley-table" class="table">
        <thead>
            <tr>
                <th></th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
    <div class="element-condition-wrapper">
        <table id="element-check-table" class="table">
            <thead>
                <tr>
                    <th>Element Check</th>
                    <th class="result-column">Result</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
        <table id="condition-check-table" class="table">
            <thead>
                <tr>
                    <th colspan="2">Left Identity Element</th>
                    <th colspan="2">Right Identity Element</th>
                </tr>
                <tr>
                    <th>Condition</th>
                    <th class="result-column">Result</th>
                    <th>Condition</th>
                    <th class="result-column">Result</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
    <div style="height: 10px;"></div>
    <div class="navigation-controls">
        <button class="previous round" id="backward"><b>&#8249;</b></button>
        <div class="step-label" id="step-label">Step: 1</div>
        <button class="next round" id="forward"><b>&#8250;</b></button>
    </div>

    <script>
        const mathContent = document.getElementById('mathContent');
        const setSelect = document.getElementById('set-select');
        const elementCountSelect = document.getElementById('element-count');
        const positiveResultsSelect = document.getElementById('positive-results');
        const positiveResultsLabel = document.getElementById('positive-results-label');
        const cayleyTableHtml = document.getElementById('cayley-table');
        const elementCheckTableHtml = document.getElementById('element-check-table');
        const conditionCheckTableHtml = document.getElementById('condition-check-table');
        const stepLabel = document.getElementById('step-label');
        const forwardButton = document.getElementById('forward');
        const backwardButton = document.getElementById('backward');

        const sets = {
            Letters: ['a', 'b', 'c', 'd', 'e', 'f'],
            Arrows: ['←', '↑', '→', '↓', '↶', '↷'],
            Emoji: ['😃', '🤔', '🥳', '😎', '😍', '😨'],
            Geometric: ['▲', '△', '◆', '◇', '●', '○'],
            Weather: ['☀', '⛅', '❄', '☔', '🌞', '⚡'],
            Chess: ['♔', '♕', '♖', '♗', '♘', '♙'],
            Stars: ['★', '☆', '✦', '✴', '✶', '✪'],
            Hearts: ['❤', '💛', '💙', '💜', '🧡', '❤️'],
            Animals: ['🐶', '🐯', '🐭', '🐰', '🦊', '🐼'],
            Plants: ['🌱', '🌿', '🌳', '🍀', '🌼', '🌺'],
            Food: ['🍎', '🍊', '🍋', '🍉', '🍇', '🍒'],
            Zodiac: ['♈', '♉', '♊', '♋', '♌', '♍'],
            Circles: ['🔴', '🟠', '🟡', '🟢', '🔵', '🟣'],
            Tools: ['🔧', '🔨', '🪛', '🪓', '🔗', '🪚'],
            Sports: ['⚽', '🏀', '🏈', '⚾', '🏓', '🏸'],
            Dice: ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'],
            Transport: ['🚗', '🚌', '🚎', '🚑', '🚒', '🚚'],
            FancyLetters: ['𝒞', '𝒟', 'ℰ', '𝒢', 'ℋ', 'ℐ']
        };

        const colorMap = {
            'a': '#e6194B', // Red
            'b': '#3cb44b', // Green
            'c': '#4363d8', // Blue
            'd': '#f58231', // Orange
            'e': '#911eb4', // Purple
            'f': '#f032e6', // Magenta
            'g': '#bcf60c', // Lime
            'h': '#fabebe', // Pink
            'i': '#ffe119', // Yellow
            'j': '#46f0f0', // Cyan        
        };

        let setSize = 4;
        let maxPositiveResults = 1;
        let conditionsPerCayleyTableEntry = 2;
        let totalSteps = setSize * setSize * conditionsPerCayleyTableEntry;
        let setName = 'Letters';
        let set = sets[setName];
        let elements = set.slice(0, setSize);
        let isIdentityElement = Array(setSize).fill(false);
        let step = 1;
        let cayleyTableForwardSteps = [];
        let cayleyTableBackwardSteps = [];
        let elementCheckForwardSteps = [];
        let elementCheckBackwardSteps = [];
        let conditionCheckForwardSteps = [];
        let conditionCheckBackwardSteps = [];
        let cayleyTableData = [];
        // This array helps by ensuring the number of positive results are correct and 
        // to extract the result from a simple array instead of reverse engineering the value from the HTML.
        // Each value has a left and right part, no need for two different arrays.
        let identityResults = defaultIdentityResultsArray();

        setSelect.addEventListener('change', (event) => {
            updateSet();
        });

        function updateSet() {
            setName = setSelect.value;
            set = sets[setName];
            generateElementsData();
            generateTable();
            startSteps();
        }

        elementCountSelect.addEventListener('change', (event) => {
            updateSize();
        });

        function updateSize() {
            setSize = parseInt(elementCountSelect.value, 10);
            totalSteps = setSize * setSize * conditionsPerCayleyTableEntry

            generateElementsData();
            updatePositiveResultsSelector();
            generateIdentityIndicatorArray();
            generateTable();
            startSteps();
        }

        positiveResultsSelect.addEventListener('change', (event) => {
            updatePositiveResults();
        });

        function updatePositiveResults() {
            generateIdentityIndicatorArray();
            generateTable();
            startSteps();
        };

        function generateElementsData() {
            elements = set.slice(0, setSize);
        }

        function updatePositiveResultsSelector() {
            positiveResultsSelect.innerHTML = '';
            if (setSize === 1) {
                const option = document.createElement('option');
                option.value = 1;
                option.textContent = 1;
                positiveResultsSelect.appendChild(option);
                positiveResultsLabel.textContent = '(there can only be 1)';
            } else {
                for (let i = 0; i <= maxPositiveResults; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = i;
                    positiveResultsSelect.appendChild(option);
                }
                positiveResultsSelect.value = '1';
                positiveResultsLabel.textContent = `(0 - ${maxPositiveResults})`;
            }
        }

        function generateIdentityIndicatorArray() {
            const positiveCount = parseInt(positiveResultsSelect.value, 10);
            isIdentityElement = Array(setSize).fill(false);
            if (positiveCount === 1) {
                const randomIndex = Math.floor(Math.random() * setSize);
                isIdentityElement[randomIndex] = true;
            }
        }

        function arraysAreEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            return arr1.every((value, index) => value === arr2[index]);
        }

        function generateTableData() {
            generateCayleyTableData();
            generateIdentityResults();
        }

        function generateCayleyTableData() {
            cayleyTableData = Array.from({ length: setSize }, () => Array(setSize).fill(null));
            const identityRowValues = elements.slice(0, setSize);
            const identityColumnValues = elements.slice(0, setSize);

            elements.forEach((element, index) => {
                const isIdentity = checkIsIdentityElement(index);
                if (isIdentity) {
                    // Set row and column corresponding to the identity element
                    for (let i = 0; i < setSize; i++) {
                        cayleyTableData[index][i] = elements[i]; // e * x = x
                        cayleyTableData[i][index] = elements[i]; // x * e = x
                    }
                } else {
                    for (let i = 0; i < setSize; i++) {
                        if (cayleyTableData[index][i] === null) {
                            cayleyTableData[index][i] = elements[Math.floor(Math.random() * setSize)];
                        }
                        if (cayleyTableData[i][index] === null) {
                            cayleyTableData[i][index] = elements[Math.floor(Math.random() * setSize)];
                        }
                    }
                }
            });

            // Fill the rest of the table with random values if still null
            for (let rowIndex = 0; rowIndex < setSize; rowIndex++) {
                for (let colIndex = 0; colIndex < setSize; colIndex++) {
                    if (cayleyTableData[rowIndex][colIndex] === null) {
                        cayleyTableData[rowIndex][colIndex] = elements[Math.floor(Math.random() * setSize)];
                    }
                }
            }
        }

        function defaultIdentityResultsArray() {
            const defaultIdentityResults = [];
            for (let i = 0; i < setSize; i++) {
                const row = [];
                for (let j = 0; j < setSize; j++) {
                    row.push({ left: false, right: false });
                }
                defaultIdentityResults.push(row);
            }
            return defaultIdentityResults;
        }

        function generateIdentityResults() {
            identityResults = defaultIdentityResultsArray();
            for (let rowIndex = 0; rowIndex < setSize; rowIndex++) {
                for (let colIndex = 0; colIndex < setSize; colIndex++) {
                    identityResults[rowIndex][colIndex].left = checkLeftIdentityCondition(rowIndex, colIndex);
                    identityResults[rowIndex][colIndex].right = checkRightIdentityCondition(rowIndex, colIndex);
                }
            }
        }

        function checkIsIdentityElement(index) {
            return setSize === 1 || isIdentityElement[index];
        }

        function checkLeftIdentityCondition(rowIndex, colIndex) {
            const value = cayleyTableData[rowIndex][colIndex];
            const expectedValue = elements[colIndex];
            return value === expectedValue;
        }

        function checkRightIdentityCondition(rowIndex, colIndex) {
            const value = cayleyTableData[rowIndex][colIndex];
            const expectedValue = elements[rowIndex];
            return value === expectedValue;
        }

        function generateTable() {
            clearTables();
            generateTableData();
            renderTableHeaders();
            renderTableRows();
            renderElementCheckTable();
            renderConditionCheckTable();
        }

        function clearTables() {
            cayleyTableHtml.querySelector('thead tr').innerHTML = '<th class="operation-symbol">*</th>';
            cayleyTableHtml.querySelector('tbody').innerHTML = '';
            elementCheckTableHtml.querySelector('tbody').innerHTML = '';
            conditionCheckTableHtml.querySelector('tbody').innerHTML = '';
        }

        function renderTableHeaders() {
            const thead = cayleyTableHtml.querySelector('thead tr');
            thead.innerHTML = '<th class="operation-symbol">*</th>';
            elements.forEach(element => {
                const th = document.createElement('th');
                th.textContent = element;
                th.style.color = colorMap[element] || 'black';
                thead.appendChild(th);
            });
        }

        function renderTableRows() {
            const tbody = cayleyTableHtml.querySelector('tbody');
            elements.forEach((element, rowIndex) => {
                const row = document.createElement('tr');
                const th = document.createElement('th');
                th.textContent = element;
                th.style.color = colorMap[element] || 'black';
                row.appendChild(th);

                for (let colIndex = 0; colIndex < setSize; colIndex++) {
                    const td = document.createElement('td');
                    const cellElement = cayleyTableData[rowIndex][colIndex];
                    td.innerHTML = `<span style="color: ${colorMap[cellElement] || 'black'}">${cellElement}</span>`;
                    td.title = `Left: ${identityResults[rowIndex][colIndex].left}\nRight: ${identityResults[rowIndex][colIndex].right}`;
                    row.appendChild(td);
                }
                tbody.appendChild(row);
            });
        }

        function renderElementCheckTable() {
            const checkTbody = elementCheckTableHtml.querySelector('tbody');
            elements.forEach(element => {
                const row = document.createElement('tr');
                const elementCell = document.createElement('td');
                elementCell.innerHTML = `Identity element e = <span style="color: ${colorMap[element] || 'black'}">${element}</span>`;
                const resultCell = document.createElement('td');
                resultCell.classList.add('result-column');
                row.appendChild(elementCell);
                row.appendChild(resultCell);
                checkTbody.appendChild(row);
            });
        }

        function renderConditionCheckTable() {
            const conditionCheckTbody = conditionCheckTableHtml.querySelector('tbody');
            elements.forEach((element, index) => {
                const row = document.createElement('tr');

                const leftConditionCell = document.createElement('td');
                leftConditionCell.innerHTML = `e <span class="operation-symbol">*</span> <span style="color: ${colorMap[element] || 'black'}">${element}</span> = <span style="color: ${colorMap[element] || 'black'}">${element}</span>`;
                const leftResultCell = document.createElement('td');
                leftResultCell.classList.add('result-column');

                const rightConditionCell = document.createElement('td');
                rightConditionCell.innerHTML = `<span style="color: ${colorMap[element] || 'black'}">${element}</span> <span class="operation-symbol">*</span> e = <span style="color: ${colorMap[element] || 'black'}">${element}</span>`;
                const rightResultCell = document.createElement('td');
                rightResultCell.classList.add('result-column');

                row.appendChild(leftConditionCell);
                row.appendChild(leftResultCell);
                row.appendChild(rightConditionCell);
                row.appendChild(rightResultCell);

                conditionCheckTbody.appendChild(row);
            });
        }

        function startSteps() {
            step = 1;
            showForwardStep();
        }

        function updateStepLabel() {
            stepLabel.textContent = `Step: ${step}`;
        }

        function updateButtonStates() {
            if (step <= 1) {
                backwardButton.classList.add('disabled');
                backwardButton.classList.remove('enabled');
            } else {
                backwardButton.classList.remove('disabled');
                backwardButton.classList.add('enabled');
            }
            if (step >= totalSteps) {
                forwardButton.classList.add('disabled');
                forwardButton.classList.remove('enabled');
            } else {
                forwardButton.classList.remove('disabled');
                forwardButton.classList.add('enabled');
            }
        }

        function stepToIndexes(step) {
            const s1 = Math.floor((step - 1) / (2 * setSize)) + 1;
            const s2 = ((step - 1) % setSize) + 1;
            const propertyInt = Math.floor((step - 1) / setSize) % 2
            let property = 'Left';
            if (propertyInt === 0) {
                property = 'Left'
            } else {
                property = 'Right'
            }
            console.log(`Step: ${step}, s1: ${s1}, s2: ${s2}, property: ${property}`);

            return { s1: s1, s2: s2, property: property };
        }

        forwardButton.addEventListener('click', (event) => {
            event.preventDefault();
            if (step < totalSteps) {
                step++;
                showForwardStep();
            }
        });

        function showForwardStep() {
            if (step <= totalSteps) {

                let { s1, s2, property } = stepToIndexes(step);

                if (step > 1) {
                    if (s2 == 1 && property == 'Left') {
                        state = `newCheckElement`
                    } else {
                        state = 'sameCheckElement'
                    }

                    // Remove element highlights for Left and Right Identity in Cayley table when new element
                    if (state == `newCheckElement`) {
                        let cayleyTableHtmlRow = s1 - 1;
                        let cayleyTableHtmlCol = s1 - 1;
                        for (let colOffset = 0; colOffset < setSize; colOffset++) {
                            const resultCell = cayleyTableHtml.rows[cayleyTableHtmlRow].cells[1 + colOffset];
                            resultCell.classList.remove('left-valid', 'left-invalid', 'right-valid', 'right-invalid');
                        }
                        for (let rowOffset = 0; rowOffset < setSize; rowOffset++) {
                            const resultCell = cayleyTableHtml.rows[1 + rowOffset].cells[cayleyTableHtmlCol];
                            resultCell.classList.remove('left-valid', 'left-invalid', 'right-valid', 'right-invalid');
                        }
                    }

                    // Remove element result and result highlight for Condition table when new element check
                    if (state == `newCheckElement`) {
                        for (let offset = 0; offset < setSize; offset++) {
                            let conditionCheckTableHtmlRow = 2 + offset;
                            let resultCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[1];
                            resultCell.textContent = '';
                            resultCell.classList.remove('valid-cell', 'invalid-cell');
                            conditionCheckTableHtmlRow = 2 + offset;
                            resultCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[3];
                            resultCell.textContent = '';
                            resultCell.classList.remove('valid-cell', 'invalid-cell');
                        }
                    }

                    // Remove header highlights for previous step Left and Right Identity in Cayley table.
                    let { s1: s1Previous, s2: s2Previous, property: propertyPrevious } = stepToIndexes(step - 1);
                    if (propertyPrevious == 'Left') {
                        let cayleyTableHtmlRow = s1Previous;
                        let cayleyTableHtmlCol = s2Previous;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.remove('highlight');
                        cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.remove('highlight');
                    } else {
                        let cayleyTableHtmlRow = s2Previous;
                        let cayleyTableHtmlCol = s1Previous;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.remove('highlight');
                        cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.remove('highlight');
                    }

                    // Remove previous header highlight for Element Check table when new element
                    if (s2Previous === setSize && propertyPrevious == 'Right') {
                        const elementCheckTableHtmlRow = s1Previous;
                        elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[0].classList.remove('highlight');
                    }

                    // Remove previous header highlight for Condition table when new element
                    if (propertyPrevious == 'Left') {
                        const conditionCheckTableHtmlRow = s2Previous + 1;
                        conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[0].classList.remove('highlight');
                    }
                    if (propertyPrevious == 'Right') {
                        const conditionCheckTableHtmlRow = s2Previous + 1;
                        conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[2].classList.remove('highlight');
                    }
                }

                // Add header highlights for Left and Right Identity in Cayley table.
                {
                    if (property == 'Left') {
                        let cayleyTableHtmlRow = s1;
                        let cayleyTableHtmlCol = s2;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.add('highlight');
                        cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.add('highlight');
                    } else {
                        let cayleyTableHtmlRow = s2;
                        let cayleyTableHtmlCol = s1;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.add('highlight');
                        cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.add('highlight');
                    }
                }

                // Add element highlights for Left and Right Identity in Cayley table.
                {
                    if (property == 'Left') {
                        let cayleyTableHtmlRow = s1;
                        let cayleyTableHtmlCol = s2;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[cayleyTableHtmlCol].classList.add(identityResults[s1 - 1][s2 - 1].left ? 'left-valid' : 'left-invalid');
                    } else {
                        let cayleyTableHtmlRow = s2;
                        let cayleyTableHtmlCol = s1;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[cayleyTableHtmlCol].classList.add(identityResults[s2 - 1][s1 - 1].right ? 'right-valid' : 'right-invalid');
                    }
                }

                // Add header highlight for Element Check table when new element
                if (s2 == 1 && property == 'Left') {
                    const elementCheckTableHtmlRow = s1;
                    elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[0].classList.add('highlight');
                }

                // Add element result and result highlight for Element Check table when element checked.
                if (s2 == setSize && property == 'Right') {
                    const elementCheckTableHtmlRow = s1;
                    const resultCell = elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[1];
                    let element = elements[s1 - 1];
                    resultCell.innerHTML = checkIsIdentityElement(s1 - 1) ? `<span style="color: ${colorMap[element] || 'black'}">${element}</span> is a identity element` : `<span style="color: ${colorMap[element] || 'black'}">${element}</span>  is not a identity element`;
                    resultCell.classList.add(checkIsIdentityElement(s1 - 1) ? 'valid-cell' : 'invalid-cell');
                }

                // Add header highlight for Condition table when new element
                if (property == 'Left') {
                    const conditionCheckTableHtmlRow = s2 + 1;
                    conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[0].classList.add('highlight');
                }
                if (property == 'Right') {
                    const conditionCheckTableHtmlRow = s2 + 1;
                    conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[2].classList.add('highlight');
                }

                // Add element result and result highlight for Condition table when element checked.
                if (property == 'Left') {
                    const conditionCheckTableHtmlRow = s2 + 1;
                    const resultCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[1];
                    resultCell.textContent = identityResults[s1 - 1][s2 - 1].left ? 'True' : 'False';
                    resultCell.classList.add(identityResults[s1 - 1][s2 - 1].left ? 'valid-cell' : 'invalid-cell');
                }
                if (property == 'Right') {
                    const conditionCheckTableHtmlRow = s2 + 1;
                    const resultCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[3];
                    resultCell.textContent = identityResults[s2 - 1][s1 - 1].right ? 'True' : 'False';
                    resultCell.classList.add(identityResults[s2 - 1][s1 - 1].right ? 'valid-cell' : 'invalid-cell');
                }

                updateStepLabel();
                updateButtonStates();
            }
        }

        backwardButton.addEventListener('click', (event) => {
            event.preventDefault();
            if (step > 1) {
                step--;
                showBackwardStep();
            }
        });

        function showBackwardStep() {
            if (step >= 1) {

                let { s1: s1Previous, s2: s2Previous, property: propertyPrevious } = stepToIndexes(step + 1);

                // Remove header highlights for previous step Left and Right Identity in Cayley table.
                if (propertyPrevious == 'Left') {
                    let cayleyTableHtmlRow = s1Previous;
                    let cayleyTableHtmlCol = s2Previous;
                    cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.remove('highlight');
                    cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.remove('highlight');
                } else {
                    let cayleyTableHtmlRow = s2Previous;
                    let cayleyTableHtmlCol = s1Previous;
                    cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.remove('highlight');
                    cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.remove('highlight');
                }

                // Remove element highlights for previous step Left and Right Identity in Cayley table.
                {
                    if (propertyPrevious == 'Left') {
                        let cayleyTableHtmlRow = s1Previous;
                        let cayleyTableHtmlCol = s2Previous;
                        // cayleyTableHtml.rows[cayleyTableHtmlRow].cells[cayleyTableHtmlCol].classList.remove('left-valid', 'left-invalid');
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[cayleyTableHtmlCol].classList.remove('left-valid', 'left-invalid','right-valid', 'right-invalid');
                    } else {
                        let cayleyTableHtmlRow = s2Previous;
                        let cayleyTableHtmlCol = s1Previous;
                        // cayleyTableHtml.rows[cayleyTableHtmlRow].cells[cayleyTableHtmlCol].classList.remove('right-valid', 'right-invalid');
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[cayleyTableHtmlCol].classList.remove('left-valid', 'left-invalid','right-valid', 'right-invalid');
                    }
                }

                // Remove previous header highlight for Element Check table when new element
                if (s2Previous === 1 && propertyPrevious == 'Left') {
                    const elementCheckTableHtmlRow = s1Previous;
                    elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[0].classList.remove('highlight');
                }

                // Remove previous element result and result highlight for Element Check table when element checked.
                if (s2Previous === setSize && propertyPrevious == 'Right') {
                    const elementCheckTableHtmlRow = s1Previous;
                    elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[1].innerHTML = '';
                    elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[1].classList.remove('valid-cell', 'invalid-cell');
                }

                // Remove previous element result and result highlight for Condition table when new element
                {
                    if (propertyPrevious == 'Right') {
                        const conditionCheckTableHtmlRow = s2Previous + 1;
                        let modificationCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[3];
                        modificationCell.classList.remove('valid-cell', 'invalid-cell');
                        modificationCell.textContent = '';
                    }
                    if (propertyPrevious == 'Left') {
                        const conditionCheckTableHtmlRow = s2Previous + 1;
                        let modificationCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[1];
                        modificationCell.classList.remove('valid-cell', 'invalid-cell');
                        modificationCell.textContent = '';
                    }
                }

                // Remove previous element highlight for Condition table when new element
                {
                    if (propertyPrevious == 'Right') {
                        const conditionCheckTableHtmlRow = s2Previous + 1;
                        let modificationCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[2];
                        modificationCell.classList.remove('highlight');
                    }
                    if (propertyPrevious == 'Left') {
                        const conditionCheckTableHtmlRow = s2Previous + 1;
                        let modificationCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[0];
                        modificationCell.classList.remove('highlight');
                    }
                }

                let { s1, s2, property } = stepToIndexes(step);

                if (s2 == setSize && property == 'Right') {
                    state = `newCheckElement`
                } else {
                    state = 'sameCheckElement'
                }

                // Add header highlights for Left and Right Identity in Cayley table.
                {
                    if (property == 'Left') {
                        let cayleyTableHtmlRow = s1;
                        let cayleyTableHtmlCol = s2;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.add('highlight');
                        cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.add('highlight');
                    } else {
                        let cayleyTableHtmlRow = s2;
                        let cayleyTableHtmlCol = s1;
                        cayleyTableHtml.rows[cayleyTableHtmlRow].cells[0].classList.add('highlight');
                        cayleyTableHtml.rows[0].cells[cayleyTableHtmlCol].classList.add('highlight');
                    }
                }

                if (step < totalSteps) {
                    // Add element highlights for Left and Right Identity in Cayley table when new element
                    if (state == `newCheckElement`) {
                        let cayleyTableHtmlRow = s1;
                        let cayleyTableHtmlCol = s1;
                        for (let colOffset = 0; colOffset < setSize; colOffset++) {
                            const resultCell = cayleyTableHtml.rows[cayleyTableHtmlRow].cells[1 + colOffset];
                            resultCell.classList.add(identityResults[s1 - 1][s2 - 1].left ? 'left-valid' : 'left-invalid');
                            resultCell.classList.add(identityResults[s1 - 1][s2 - 1].right ? 'right-valid' : 'right-invalid');
                        }
                        for (let rowOffset = 0; rowOffset < setSize; rowOffset++) {
                            const resultCell = cayleyTableHtml.rows[1 + rowOffset].cells[cayleyTableHtmlCol];
                            resultCell.classList.add(identityResults[s1 - 1][s2 - 1].left ? 'left-valid' : 'left-invalid');
                            resultCell.classList.add(identityResults[s1 - 1][s2 - 1].right ? 'right-valid' : 'right-invalid');
                        }
                    }
                }

                // Add header highlight for Element Check table when new element
                if (s2 == setSize && property == 'Right') {
                    const elementCheckTableHtmlRow = s1;
                    elementCheckTableHtml.rows[elementCheckTableHtmlRow].cells[0].classList.add('highlight');
                }

                // Add header highlights in Condition table.
                {
                    if (property == 'Left') {
                        const conditionCheckTableHtmlRow = s2 + 1;
                        conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[0].classList.add('highlight');
                    }
                    if (property == 'Right') {
                        const conditionCheckTableHtmlRow = s2 + 1;
                        conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[2].classList.add('highlight');
                    }
                }

                if (step < totalSteps) {
                    // Add element highlight and result for Condtion table when new element
                    if (state == `newCheckElement`) {
                        for (let rowOffset = 0; rowOffset < setSize; rowOffset++) {
                            const conditionCheckTableHtmlRow = 2 + rowOffset;
                            const resultCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[1];
                            resultCell.textContent = identityResults[s1 - 1][s2 - 1].left ? 'True' : 'False';
                            resultCell.classList.add(identityResults[s1 - 1][s2 - 1].left ? 'valid-cell' : 'invalid-cell');
                        }
                        for (let rowOffset = 0; rowOffset < setSize; rowOffset++) {
                            const conditionCheckTableHtmlRow = 2 + rowOffset;
                            const resultCell = conditionCheckTableHtml.rows[conditionCheckTableHtmlRow].cells[3];
                            resultCell.textContent = identityResults[s2 - 1][s1 - 1].right ? 'True' : 'False';
                            resultCell.classList.add(identityResults[s2 - 1][s1 - 1].right ? 'valid-cell' : 'invalid-cell');
                        }
                    }
                }

                updateStepLabel();
                updateButtonStates();
            }
        };

        for (const setName in sets) {
            const option = document.createElement('option');
            option.value = setName;
            if (setName === 'Letters') {
                option.textContent = `${setName}: selected ${sets[setName].join(' ')}`;
            } else {
                option.textContent = `${setName}: ${sets[setName].join(' ')}`;
            }
            setSelect.appendChild(option);
        }

        function toggleSection() {
            mathContent.classList.toggle('collapsed');
        }

        updateSize();
    </script>

    <footer>
        <p>
            Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License
                2.0</a>.
        </p>
    </footer>
</body>

</html>